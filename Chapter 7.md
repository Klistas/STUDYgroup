# 데이터 구조와 처리
---

## 데이터 구조(Data Structrue)
- 데이터를 조직하는 표준적인 방법

## 참조 지역성(Locality of Reference)
- 필요한 데이터를 메모리에서 유지하고, 사용하는 데이터라면 가까운 곳에 저장하는 것.


## 기본 데이터 타입 
- 기본 데이터 타입 
    - 크기(Size) : 비트 수
    - 해석(Interpretation) : 부호의 유무, 부동소수점수 판별, 문자 판별, 포인터 판별, 불리언 판별
- 포인터(Pointer) : 간접 주소 지정 
- 참조(Reference) : 추상적인 개념

## 배열 (array)
- 인덱스(Index) : 데이터 주소
- 원소(Element) : 데이터
- 기저 주소(Base Address) : 0번째 주소를 의미 한다.
- 1차원 배열 : 한 차원에 데이터 주소가 하나씩 있는 배열.
- 다차원 배열 : 한 차원에 여러 데이터 주소가 있는 배열.

## 비트맵 (Bit map)
- 비트의 배열
- 비트맵에 대한 기본 연산
    - 비트 설정하기 : 비트들(Indexs) = 비트들(Indexs) OR 마스크
    - 비트 지우기 : 비트들(Indexs) = 비트들(Indexs) AND (NOT 마스크)
    - 비트가 1인지 검사하기 : (비트들(Indexs AND 마스크) != 0
    - 비트가 0인지 검사하기 : (비트들(Indexs AND 마스크) = 0

## 문자열(String)
- 여러 문자로 이뤄진 시퀀스(Sequence)
- char : C에서 1바이트를 나타내는 데이터 이름
- 문자열 터미네이터 : 문자열 끝을 표시하는 문자 (NUL 문자)
    - 장점 : 저장이 쉽고, 문자열의 끝까지 각 문자를 출력하는 일을 할 때, 부가 비용이 들지 않는다.

    - 단점 : 문자열의 길이를 알아내려면 문자열 터미네이터를 발견할 때 까지 문자열을 스캔하면서 문자 수를 세야 한다. 그리고 문자열 중간에 NUL 문자를 넣을 때는 사용할 수 없다.

## 복합 데이터 타입
- 스위트(suite) : 데이터 타입이라고 하며 구조체(structure)라고 한다.
    - 구조체 스위트 안에 있는 것 들을 구조체의 멤버(member)라고 한다.

- 편의 문법 : 코드를 읽기 쉽게 만들어 주는 문법.
- 구조체가 메모리를 더 많이 차지 할 때 
    - 메모리정렬을 지켜야 하므로 패딩을 추가하여 이 문제를 해결한다.
- 공용체(union) : 스위트와 같이 잘 정렬된 데이터 구조
    - 공용체를 사용하면 같은 메모리 공간이나 내용을 여러 가지 관점으로 바라볼 수 있다.

## 단일 연결 리스트
- 리스트 원소 : 메모리에서 아무 위치에나 있을 수 있다.
- 원소 삭제 : 삭제할 리스트의 원소의 바로 앞 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야한다.
- 이중 간접 주소 지정 : 간접 주소를 하나 더 추가하여 간단한 코드를 만들어 낼 수 있다. -> 더 간단하다.

## 동적 메모리 할당
- 힙 : 정적으로 할당된 데이터 영역 다음에 프로그램 런타임 라이브러리가 설정해주는 영역.
- 별도의 메모리 관리 유닛이 없다면, 힙 영역이 프로그램에 사용할 수 있는 데이터 메모리임.
    - 메모리 관리 유닛 : 런타임 라이브러리가 프로그램에게 필요한 메모리 용량을 요청.
- 동적 데이터는 힙에서 메모리를 얻음. -> 이 과정에서 필요한 것이 동적메모리 할당. (malloc, free)
    - malloc : 힙을 여러 블록으로 나누고 블록에 크기와 다음 블록에 대한 포인터 포함. 요청한 데이터만큼의 블록을 찾아서 공간에 대한 포인터를 돌려줌.
    - free : 할당한 메모리 해제. 할당된 메모리를 해제하지 않으면 메모리 누수 발생.

## 효율적인 메모리 할당
- 노드와 문자열을 각각 할당하지 않고, 이 두가지의 크기를 합한 후 할당하면 메모리 공간을 절약할 수 있다.
- 또한, 메모리 해제도 한번만 하면 되어 효율적이다.

## 가비지 컬렉션(Garbage Collection)
- malloc 과  free를 사용하지 않고 동적 메모리를 할당하기 위해 구현.(자바나 자바스크립트)
- 이런 언어에서는 포인터 대신 참조를 사용함. -> 불필요한 참조는 메모리를 낭비하게 됨.(디버깅또한 힘들어짐.)
- 혹은, new라는 연산자를 사용하는 언어도 있다. 
- 이 경우에는 변수 사용을 언어가 추적하여, 사용하지 않는 메모리를 자동으로 해제한다.
- 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다는 단점이 존재함.

## 이중 연결 리스트
- 단일 연결 리스트의 delete 함수는 포인터 변경을 위해 삭제하려는 원소의 앞 원소를 알아야함.
- 이중 연결 리스트는 노드에 다음 원소의 포인터 뿐만 아니라 이전 원소의 포인터도 가지고  잇음.
- 노드의 메모리는 늘지만, 직접 이전 원소를 찾아야하는 번거로움은 사라짐. 

## 계층적 데이터 구조
- 선형적 데이터 구조는 데이터의 양이 많아지면 많아질수록 특정 데이터를 찾기 힘들다는 단점이 있다.
- 때문에 계층적으로 데이터를 조직하는 계층적 데이터 구조가 등장했다.
    - 2진 트리 : 한 노드에 최대 2개의 노드가 연결될 수 있는 구조.
- 여러가지 알고리즘이 존재하며, 구조만 이해하면 어떠한 데이터든 찾기 쉽게하려는 목적이있다.

## 대용량 저장장치
- 디스크의 기본 단위는 블록이고 연속적인 블록을 클러스터라고 부른다.
- 하나의 클러스터에 데이터를 저장하는 방식은 바람직하지않다.
- 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록에 데이터를 나눠 담는다.
- 데이터를 디스크에 저장하기 위해서는 파일이름이라는 영구적인 존재가 필요하다.
- 아이노드 : 디스크 블록에 대한 인덱스와 노드를 합친 단어.
    - 파일 이름, 파일 소유자, 파일 크기, 파일에 대한 허가 내역 등이 포함된다.
    - 파일의 데이터가 들어 있는 블록에 대한 인덱스도 포함된다.
    - 직접 블록 포인터가 12개있기 때문에 최대 49,152바이트까지 데이터를 보관할 수 있다.
      - 그 이상 데이터는 간접블록을 사용해 4MiB까지 지원할 수 있다.
    - 간접블록보다 더 큰 파일을 저장이 필요할때는 2중 간접블록을 통해 4GiB, 3중 간접 블록을 통해 4PiB까지 지원할 수 있다.
    - 디렉터리 : 파일 이름과 파일 데이터를 가르키는 아이노드를 연결해준다.
        - 디렉터리가 다른 디렉터리를 참조할 수 있고, 이로 인해 계층적 파일 시스템이 생겨났다.
    - 링크 : 여러 아이노드가 같은 블록을 참조할 수 있고, 각 참조를 링크라 한다.
        - 심볼릭 링크 : 디렉터리에 대해 링크를 할 수 있다.
            - 심볼릭 링크를 사용하면 파일 시스템 그래프에 루프가 생기고, 이를 감지할 특별한 코드가 필요하다.
    - 가용공간 : 각 블록을 1비트로 표현하느 비트맵을 사용한 방식
        - 비트맵을 사용하면 간단하면서 효율적이다.
    
## 데이터베이스
- 데이터베이스 : 정해진 방식으로 조직화된 데이터 모음
- 데이터베이스 관리 시스템 : 데이터베이스에 정보를 저장하고 읽어올 수 있게 해주는 프로그램
- B 트리 : 균형 2진 트리보다는 공간을 덜 효율적으로 사용하지만 디스크에 데이터를 저장할 때 성능이 더 낫다.
        - 노드에 저장하는 키 수가 더 많으면 노드를 디스크에서 더 적게 읽어올 수 있다.

## 인덱스
- 인덱스 : 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다. 
   - 데이터 = 책의 내용, 인덱스 = 책의 목차, 물리적 주소 = 책의 페이지 번호라고 생각할 수 있다.

## 데이터 이동
- 루프 언롤링(Loop unrolling) : for문과 비슷하다.
- 더프의 장치(Duff's Device) : Switch문과 비슷하다.
- 데이터 이동하기 위해 복사를 할 때 조건에 따라 영역이 겹치는 경우, 복사 시 조심해야 한다.
   - 유의 사항 대처 방법 : 역방향으로 복사한다.

## 벡터를 사용한 I/O
- 파일은 여러 프레임으로 구성되어 있고, 각 프레임은 헤더와 데이터로 구성된다.
- 시스템에게 프레임의 각 부분을 가르키는 포인터의 집합을 전달하고, 시스템이 데이터를 쓸 때 각 부분을 하나로 합쳐주면 효율적이다.
- 시스템 콜 : 크기와 데이터에 대한 포인터로 이뤄진 벡터를 운영체제에 넘기는 것
   - 데이터를 쓸 때와 읽을 때 모두 벡터를 사용할 수 있다.
   - 수집 : 벡터를 활용해 데이터를 여러 위치에서 데이터를 모아서 쓰는 행위
   - 분산 : 벡터를 사용해 데이터를 여러 위치로 데이터를 분산 시키는 행위
- 버클리 네트워크 코드는 분산/수집을 이용한다.
    
## 객체 지향의 함정
- 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티(property)가 들어있다.
- 모든 데이터와 함수가 들어있기 때문에 메소드가 많으면 구조체가 커질수 있지만 메소드를 별도의 데이터 구조에 담아 해결할수 있다.
- 하지만 객체와 관련된 부가 비용이 존재하기 때문에 성능이 결정적으로 중요할때는 전통적인 배열을 활용하는 것이 좋다.

## 정렬
- 정렬을 하는 이유
  - 데이터를 정렬해서 저장하면 메모리 접근 횟수를 줄임으로써 검색을 빨리 끝낼수 있다.
-  qsort : 퀵정렬 알고리즘을 구현한 라이브러리 함수
   - 데이터를 정렬하는 방법을 알고 있지만 데이터를 비교하는 방법은 알지 못하기 때문에 함수 포인터를 사용한다.
   - 두 원소 a와 b가 있을때 두 값을 비교한 값을 돌려주는 함수를 가리키는 포인터를 함께 전달한다.
   
## 해시(Hash)
- 해싱(hasing) : 키값을 해시 함수라는 수식에 대입시켜 계산한 후 나온 결과를 주소로 사용하여 바로 값에 접근하게 할 수 있는 방법
  - 하지만 해시 함숫값의 범위가 너무 크면 데이터를 너무 많이 사용하거나, 데이터가 너무 여기저기 흩어져서 메모리 접근 성능이 떨어질수있다. 
- 해시 테이블 : 해시 함수의 결과를 배열 인덱스(버킷)로 만든 것. 
- 충돌(collision) : 서로 다른 두 개의 입력값에 대해 동일한 출력값을 내는 상황
  - 분리 연결법 : 여러 데이터가 동일한 버킷으로 접근을 한다면 추가 메모리를 사용하여 다음 데이터의 주소를 저장하여 데이터들을 연결을 해서 관리 하는 방법. 데이터가 많아지면 그에 따라 캐시 효율성이 감소한다.
  - 개방 주소법 : 비어있는 해시 테이블의 공간을 활용하는 방법이다.
    > 1. Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해서 비어 있는 버킷에 데이터를 저장한다.
    > 2. Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2², 3² 칸씩 옮기는 방식이다.
    > 3. Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애 버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들 보다 많은 연산을 하게 된다. 
- 완전 해시 : 각 키를 유일한 버킷에 연결해 주는 방식으로 모든 키를 미리 알고 있지 않다면 완전한 해시 함수를 만드는 것은 거의 불가능하다.

## 효율성과 성능
- 샤딩(Sharding) : 수평 파티셔닝(horizontal partitioning)이라 부르며 인터페이스를 통한 요청을 모든 샤드에 전달하고 컨트롤러가 결과를 하나로 모으는 방법으로 작업을 여러 작업자로 나눠 수행함으로써 성능이 향상된다.
- 맵리듀스(MapReduce) : 샤딩의 변종으로 근본적으로 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다.
