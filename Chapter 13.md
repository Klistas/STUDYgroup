# 컴퓨터 보안

---

- 보안 : 컴퓨터 상에서의 개인 정보나 코드의 안전을 보장하는 것.
- 보안 유지는 매우 어렵기 때문에 그만큼 더 신경을 써야함.

---

## 보안과 프라이버시 개요
- 위협 모델
    - 보안에 어떤 위협이 있을지 예상한 것.
    - 인간의 행동을 예상하기는 어렵기 때문에, 가능한 많은 위협모델을 정의 해야한다.
    - 따라서, 보안은 위협 모델에 따라 상대적.

- 신뢰
    - 어떤 대상에게 액세스하게 해주는 것. 
    - 최소화 할 수록 보안은 견고해짐.
    - 세가지 유형의 신뢰 위반 유형 고려.
        - 의도적 : 악의적으로 이를 이용. (멀웨어)
        - 무능 : 견고하지 않은 보안. (잘못 만들어진 보안 시스템)
        - 부정직 : 의도적으로 강화되지 않은 암호 표준을 사용. -> 클렙토그래피(부정직 위반으로 공격자가 안전하게 정보를 꺼냄.)
    - 모호성에 의한 보안 : 보안이 모호하면 안전함 -> 투명성과 개방성이 더 안전한 보안.

- 물리적 보안
    - 공격 표면 : 보안상의 공격을 당하는 곳.
    - 보통의 공격 표면은 암호등으로 보호되고 있으며, 사용자에게만 접근 권한을 부여.
    - 권한을 부여 받지 못한 사람의 접근을 제한한다.
    - 보통의 공격 표면은 앞에 존재. -> but, 뒤쪽의 백도어가 존재(마스터키)

- 통신 보안
    - 통신 간에 보안을 유지하려면 인증을 거쳐야함.
        - 인증 : 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정.
        - 크립토그래피를 통하여 해결이 가능.

- 모던 타임즈
    - 초기에는 컴퓨터의 물리적 보안만 신경쓰면 되었다. -> 인터넷 등으로 컴퓨터들이 연결되기 시작하며, 통신보안의 중요성이 두드러짐.
    - 통신을 통한 여러가지 위협이 존재함.
        - DoS : 서비스 거부 공격. 특정 서비스에 지속적으로 요청을 전달하여, 정상적인 사용자들이 이용할 수 없게 만듬. 여러 곳에서 동시다발적으로 진행되는 것이 DDoS(분산 서비스 거부 공격).
        - 이러한 위협에서 공격자 추적이 어려운 이유는 프록시를 사용하기 때문이다.
        - 다른 여러 컴퓨터에 멀웨어를 설치하여, 여러 컴퓨터들에게 공격하게 만든다.
    - 공격의 주된 두가지 유형
        - 크립토그래피 시스템 공격 : 크립토그래피 보안 시스템을 직접적으로 공격함. 상대적으로 드물고, 보안이 잘 설계되었다면 뚫기 어렵다.
        - 사회적 공격 : 메일 등으로 타인이 컴퓨터에 멀웨어를 설치하게 함으로써 공격함. 가장 주된 방법.
    - 현대 기술의 발달로 진짜 정보처럼 인위적으로 만든 정보들이 정교해져감 -> 진본을 결정하기 어려움 (딥페이크)

- 메타 데이터와 감시
    - 메타 데이터 : 데이터에 대한 데이터. 데이터의 송, 수신자의 정보로 이를 이용하여 네트워크로의 접근도 가능하다.
    - SNS등의 발달로 메타 데이터로의 추적이 더욱 쉬워졌다.

- 사회적 맥락
    - 정치, 경제, 사회적인 문제들과 맞물려 보안은 더욱 큰 문제로 떠올랐다.
        - 기술의 발달이 보안의 발달을 의미하지는 않으므로, 민간인 사찰등의 문제가 대두됨.
        - 개인 정보의 매매도 공공연히 이루어지고 있다.
        - 이로인해 개인의 자유, 안전등에 영향을 끼치고 있다.

- 인증과 권한 부여
    - 두 가지의 보안방법 중 권한부여가 더 쉬운 방법이다.
        - 권한 부여는 제대로 설계, 구현된 하드웨어와 소프트웨어로 해결 가능.
        - 인증은 패스워드만 알면 인증할 수 있기 때문에 더 복잡한 절차를 거쳐야 한다.

---

## 크립토그래피
- 크립토그래피란 암호화를 통하여 송신하고, 수신자는 이를 복호화하여 정보를 받는다.
- 이는 보안 뿐만 아니라, 위조, 변조를 막거나 감지할 수 있다.

---

### 스테가노그래피
- 어떤 내용을 다른 내용 속에 감추는 방식
- 송신자와 수신자 사이의 연결의 자취가 남지 않는다.
- 이미지에서 특정 비트를 제거하거나, 텍스트의 모양을 살짝바꾸는 방법등이 있다.
- 거의 모든 컴퓨터 프린터에 이 기법이 사용되며, 이외에도 광고, 제한된 정보를 사용하는 곳에서 사용이 가능하다.

---

### 치환 암호
- 문자를 다른 문자로 치환한 표를 토대로 암호화하고, 역으로 치환하여 복호화한다.
- 복호화된 원래 메시지를 평문, 암호화된 메시지를 암호문이라고 한다.
- 컴퓨터 이전부터 쓰였던 방법으로 그리 안전하지만은 않은 방법이다.

---

### 전치 암호
- 문자 위치를 뒤섞는 방식
- 고대 그리스에서부터 쓰였던 방식으로 스키테일이라고 부른다.
- 과거에는 막대기에 종이를 감아 적는 방법이나, 정해진 크기의 격자에 메시지를 적는 방식으로 사용하였다.
- 최근에는 아주 쉽게 풀 수 있어 안전하지 않다.

---

### 일회용 패드
- 중복되지 않는 유일한 치환 암호들의 모음으로, 각 치환 암호 코드를 단 한번만 사용했다.
- 한번 사용되고 다신 사용되지 않았으므로, 치환표를 알아낸다고 하여, 다음 암호에는 다른 치환표가 사용되므로 안전하다.

---

### 공개키 암호
- 서로 연관된 키 쌍을 사용.
- 모두에게 공개되어있는 공개키와 같은 키를 공유하는 사람들만 가지고 있는 비밀키가 있다.
- 비밀키를 이용하여, 서로 통신하는 사람들만 공개키를 복호화 하는 방식.
- 암호화와 복호화에 사용하는 키가 달라 비대칭 시스템이라고 한다.
- 한 방향으로는 계산하기 쉽지만, 다른 방향에서는 어려운 트랩도어 함수를 사용한다.

---

### 전방향 안전성
- 대칭 암호 세션 키를 사용할 때, 키를 발견하면 쉽게 복호화되어 안전하지 않음.
- 이를 방지하기 위한 방법. -> 각 메시지마다 새로 세션 키를 만든다.

---

### 암호학적 해시 함수
- 해시 함수와 마찬가지로 임의의 입력을 미리 정해진 범위의 수로 변환.
- 단방향함수 -> 해시값을 만들기는 쉬우나, 해시에서 무언가를 하기에는 어렵다.
- 비슷한 입력이라고해서 해시값도 비슷하지는 않다.

---

### 디지털 서명
- 데이터가 진본임을 검증함.
    - 정합성 : 메시지가 변조됐는지 검증
    - 부인 방지 : 메시지를 보낸 사람이 보내지 않았다고 주장 할 수 없음. -> 비밀키를 사용하기 때문에 가능.
    - 인증 : 비밀키는 누가 가지고 있는지 서로 알고 있고, 변조여부는 정합성 판단으로 알 수 있기 때문에 그 사람이 보낸, 원본 메시지라는 것을 알 수 있다.

---

### 공개키 인프라
- 공개키 인프라스트럭처
    - 제 3자인 인증기관에서 키가 어떤 사람의 것인지 인증해준다.
    - 인증기관의 신뢰도에 따라, 안전할 수도, 그렇지 않을 수도 있다.

---

### 블록체인
- 크립토그래피를 응용.
- 어떠한 블록에는 각각 데이터가 담겨있고, 생성시간과 이전 블록에 대한 암호학적 해시를 추가한다.
- 이로써 블록끼리 체인을 갖게 되고, 한 블록에서 데이터의 변화가 일어나면 이전 블록의 해시도 달라지므로, 보안의 신뢰도를 가지게 된다.

---

### 패스워드 관리
- 예전에는 패스워드 파일에 평문으로 저장하고, 그 사람이 입력한 패스워드와 파일에 저장된 패스워드를 비교했다.
- 아주 안전하지 않은 방법으로, 접근만 한다면 모든 패스워드를 바로 알 수 있었다.
- 때문에 패스워드를 암호학적 해시와 같은 방식으로 저장하면, 공격을 당해도 패스워드를 알 수 없기 때문에 비교적 안전해졌다.
- 하지만, 최근에는 멀웨어등의 프로그램, 그리고 사용자들의 보안이 취약한 패스워드 사용으로 더 더욱 강화된 인증을 사용한다.

---

## 보안을 위한 소프트웨어 예방 조치

---

### 올바른 대상을 보호하라
- 모든 대상을 안전하게 하는 것이 아닌, 올바른 대상만 보호하게 하는 것이 좋다.

---

### 로직은 세 번 체크하라
- 프로그래머가 찾지 못한 버그를 공격자가 찾을 수 있다면 공격자는 소스 코드를 통해 공격에 성공할 가능성이 높아진다.
- 이를 방지하기위해 다른 사람과 코드를 검토하는것이 좋다.

---

### 오류를 검사하라
- 오류나 경고 보고를 항상 활성화하고, 이를 무시하지 말고 해결해야한다.

---

### 공격 표면을 최소화하라
- 코드를 가능한 한 간단하게 유지해서 공격 표면을 줄이는 것이 좋은 보안 방법이다.

---

### 경계 내부에 머물러라
- 1. 버퍼 오버플로 : 소프트웨어가 데이터의 메모리 경계를 체크하지 않고 다른 데이터를 덮어쓸 수 있는 경우이다.
- 2. 변수 크기가 문제가 될 수 있다.
- 3. 메모리 경계 안에 머무는 것도 중요하다.
- 4. 입력이 인터럽트 핸들러가 처리할 수 있는 속도보다 빨리 들어와도 프로그램이 입력을 제대로 처리할 수 있게 해야한다.

---

### 좋은 난수를 생성하기는 힘들다
- 논리 회로로는 진짜 난수를 만들 수 없고 대신에 의사 난수를 샤용한다.
- 의사난수는 난수가 주기적으로 반복되고, 가장 최근의 난수를 알면 바로 다음 난수를 쉽게 알수 있다는 단점이 있다.
- 완벽한 난수를 만들 수는 없지만, 최대한 복잡하게 난수를 만드는 방법들이 여러가지 있다.

---

### 네 코드를 알라
- 프로젝트가 커지면 다른 회사(벤터)가 만든 코드를 써야할 때가 있다.
- 하지만 이런 코드들은 버그가 있거나 비밀 백도어를 심어두거나, 우리가 필요 없는 코드들이 더 많을 수도 있다.
- 이런 부분을 방지하기위해 코드를 오픈해 다른 사람들이 버그나 비밀 백도어를 찾을 수 있게 할 수도 있고, 프로그래머 자신이 필요한 부분만 사용하면 된다.

---

### 극단적인 영리함은 여러분의 적이다
- 벤더가 만든 코드들 중 이상하고 영리한 기능은 피해야한다.
- 이런 기능들은 밴더가 업그레이드 해주지 않거나 버그 픽스를 제공해주지 않을 수 있다.

---

### 눈에 보이는 것을 이해하라
- 사이드 채널 공격 : 프로그램 구현의 메타데이터나 부작용에 기반을 둔 공격 방법
- 반 에크 프리킹 : 전자기파 방사를 기반으로 한 공격으로 안테나를 사용해 모니터 방사파를 잡아내서 모니터에 표시된 이미지를 원격에서 재현할 수 있다.
- 중요한 보안 코드에 대해 외부에서 관찰할 수 있는 행동이 실제 내부에서 일어나고 있는 일과는 무관하게 만들어야한다.

---

### 과다수집하지 마라
- 정말 필요한 경우가 아니라면 민간함 정보를 수집하면 안된다.

---

### 모아두지 마라
- 민감한 정보를 수집했다면 가능하면 빨리 민감한 정보를 없애야한다.

---

### 동적 메모리 할당은 여러분의 친구가 아니다
- 동적 메모리를 사용한다면 메모리를 해제하기 전에 민감한 정보를 지워야한다.
- 메모리를 줄이는 경우 그에 따라 반환될 영역에 있는 정보를 지워야한다.
- 보안이 필수적인 경우 realloc을 사용하면 안된다.
    - 효율적이지는 않지만 안전한 방법으로 malloc으로 새 메모리를 할당하고 이전 데이터를 복사한 다음 민간함 데이터를 덮어써 지우고 free로 해제해야한다.

---

### 가비지 컬렉션도 여러분의 친구가 아니다
- 가비지 컬렉션을 사용하는 언어는 민감한 정보를 덮어쓰는 대신 세로운 문자열을 할당한 다음 민간함 정보가 담긴 문자열은 가비지 컬렉션이 가능한 문자열로 분류한다.
- 이렇게 된다면 민감한 정보는 지워지지 않고 이 정보를 강제로 지울 방벙도 없다.
